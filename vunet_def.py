# -*- coding: utf-8 -*-
"""VUnet_def.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ma4OpP7HDCKWSH3DKAGGjCl_ioJWhk8n
"""


!pip install fastai==1.0.61

import fastai
from fastai import *
from fastai.torch_core import *
from fastai.layers import *
from fastai.callbacks.hooks import *
from fastai import *
from fastai.vision import *

def _get_sfs_idxs(sizes:Sizes) -> List[int]:
    "Get the indexes of the layers where the size of the activation changes."
    feature_szs = [size[-1] for size in sizes]
    sfs_idxs = list(np.where(np.array(feature_szs[:-1]) != np.array(feature_szs[1:]))[0])
    if feature_szs[0] != feature_szs[1]: sfs_idxs = [0] + sfs_idxs
    return sfs_idxs

class UnetBlock_VAE_encoder_novar(Module):
    "A quasi-UNet block, using `PixelShuffle_ICNR upsampling`."
    #@delegates(ConvLayer.__init__)
    #Siwei: add an input for the resized image (x_pix,y_pix)
    #Siwei: add an input for latent_dims (default latent_dims=x_in_c)
    def __init__(self, up_in_c:int, x_in_c:int, x_pix:int, y_pix:int, latent_dims:int, hook:Hook, logvar_t:float=-1.0, final_div:bool=True, blur:bool=False, leaky:float=None,
                 self_attention:bool=False, **kwargs):
        self.hook = hook
        self.x_in_c = x_in_c
        self.x_pix = x_pix
        self.y_pix = y_pix
        self.latent_dims = latent_dims
        #the encoder part only
        self.layerlist = nn.ModuleList()
        
        self.layerlist.append(nn.Linear(x_in_c*x_pix*y_pix, latent_dims)) #fc_mu 0
        #self.layerlist.append(nn.Linear(x_in_c*x_pix*y_pix, latent_dims)) #fc_logvar 1
        self.layerlist.append(nn.BatchNorm1d(latent_dims)) #bn_mu 1
        #self.layerlist.append(nn.BatchNorm1d(latent_dims)) #bn_logvar 3
        self.logvar_t = torch.cuda.FloatTensor([logvar_t])

    def reparameterize(self, mu, log_var,random=True):
        """
        :param mu: mean from the encoder's latent space
        :param log_var: log variance from the encoder's latent space
        """
        #std = torch.exp(0.5*log_var) # standard deviation
        eps = torch.exp(torch.tensor(0.5*-1.0)) * torch.randn_like(mu)
        #eps = torch.randn_like(std) # `randn_like` as we need the same size
        if self.training:
            sample = mu + eps
        else:
            sample = mu
        
        #sample = mu + (eps * std) # sampling as if coming from the input space
        return sample
    
    def forward(self, up_in): #siwei: first ReLu, then conv2 then conv1?
        s = self.hook.stored
        #
        #encoding pass
        
        s_vae = s.view(-1,self.x_pix*self.y_pix*self.x_in_c) #Siwei: must do for variational sampling, flatten batch of multi-channel feature maps to a batch of feature vectors
        
        s_mu=self.layerlist[1](self.layerlist[0](s_vae))#, self.layerlist[3](self.layerlist[1](s_vae))
        #s_mu = self.fc_mu(s)
        #s_logvar = self.fc_logvar(s)
        z_sample = self.reparameterize(s_mu, self.logvar_t)

        return z_sample

class UnetBlock_VAE_decoder(Module):
    "A quasi-UNet block, using `PixelShuffle_ICNR upsampling`."
    #@delegates(ConvLayer.__init__)
    #Siwei: add an input for the resized image (x_pix,y_pix)
    #Siwei: add an input for latent_dims (default latent_dims=x_in_c)
    def __init__(self, up_in_c:int, x_in_c:int, x_pix:int, y_pix:int, latent_dims:int, hook:Hook, final_div:bool=True, blur:bool=False, leaky:float=None,
                 self_attention:bool=False, **kwargs):
        self.hook = hook
        self.up_in_c = up_in_c
        self.x_in_c = x_in_c
        self.x_pix = x_pix
        self.y_pix = y_pix
        self.latent_dims = latent_dims
        ni = up_in_c//2 + x_in_c
        nf = ni if final_div else ni//2
        self.logvar_t = -1.0 #this is only useful for novar encoder

        self.layerlist = nn.ModuleList()
        self.layerlist.append(UnetBlock_VAE_encoder_novar(up_in_c, x_in_c, x_pix, y_pix, latent_dims, hook, self.logvar_t, final_div, blur=blur, leaky=leaky, self_attention=self_attention, **kwargs)) #0
        #self.layerlist.append(UnetBlock_VAE_encoder(up_in_c, x_in_c, x_pix, y_pix, latent_dims, hook, final_div, blur=blur, leaky=leaky, self_attention=self_attention, **kwargs)) #0
        self.layerlist.append(nn.Linear(latent_dims, x_pix*y_pix*x_in_c)) #fc 1
        self.layerlist.append(batchnorm_2d(x_in_c)) #2
        self.layerlist.append(PixelShuffle_ICNR(up_in_c, up_in_c//2, blur=blur, leaky=leaky, **kwargs)) #3
        self.layerlist.append(conv_layer(ni, nf, leaky=leaky, **kwargs)) #conv1 4
        self.layerlist.append(conv_layer(nf, nf, leaky=leaky, self_attention=self_attention, **kwargs)) #conv2 5
        self.layerlist.append(relu(leaky=leaky)) #6
    
    def forward(self, up_in):
        s = self.hook.stored
        z_sample = self.layerlist[0](s)
        z_s = self.layerlist[1](z_sample)
        z_s = z_s.view(-1, self.x_in_c,self.x_pix,self.y_pix) #check the size of ni, or the original cat_x
        z_s = self.layerlist[2](z_s) #2d batchnorm
        up_out = self.layerlist[3](up_in) #pixel shuffle
        ssh = z_s.shape[-2:]
        if ssh != up_out.shape[-2:]:
            up_out = F.interpolate(up_out, z_s.shape[-2:], mode='nearest')

        cat_x = torch.cat([up_out, z_s], dim=1) #Siwei: this is the decoding step
        #cat_x size: ni, but why not the size of 4 by 4? 
        #cat_x = self.relu(torch.cat([up_out, self.bn(z_s)], dim=1)) #VAE version
        return self.layerlist[6](self.layerlist[5](self.layerlist[4](cat_x))) #final decoding

class VariationalAutoencoder(Module):
  def __init__(self, x_in_c:int, x_pix:int, y_pix:int, latent_dims:int, leaky:float=None,
                 self_attention:bool=False, **kwargs):
        #super(VariationalAutoencoder, self).__init__()
        self.x_in_c = x_in_c
        self.x_pix = x_pix
        self.y_pix = y_pix
        self.latent_dims = latent_dims

        self.layerlist = nn.ModuleList()
        #self.layerlist.append(conv_layer(x_in_c, x_in_c*2, **kwargs)) #fc_mu 0
        self.layerlist.append(nn.Linear(x_in_c*x_pix*y_pix, latent_dims)) #fc_mu 1
        self.layerlist.append(nn.Linear(x_in_c*x_pix*y_pix, latent_dims)) #fc_logvar 1
        self.layerlist.append(nn.Linear(latent_dims, x_pix*y_pix*x_in_c)) #fc 2
        
  def forward(self, x):
        s_vae = x.view(-1,self.x_pix*self.y_pix*self.x_in_c) #Siwei: must do for variational sampling, flatten batch of multi-channel feature maps to a batch of feature vectors
        
        s_mu, s_logvar=self.layerlist[0](s_vae), self.layerlist[1](s_vae)
        #s_mu = self.fc_mu(s)
        #s_logvar = self.fc_logvar(s)
        z_sample = self.reparameterize(s_mu, s_logvar)

        #decoding pass
        z_s = self.layerlist[2](z_sample)
        z_sample = z_s.view(-1, self.x_in_c,self.x_pix,self.y_pix) #check the size of ni, or the original cat_x
        #z_s = self.layerlist[5](z_s)
        return z_sample
  def reparameterize(self, mu, logvar):
        if self.training:
            # the reparameterization trick
            std = logvar.mul(0.5).exp_()
            eps = torch.empty_like(std).normal_()
            return F.relu(eps.mul(std).add_(mu))
            #return eps.mul(std).add_(mu)
        else:
            return mu

class DynamicUnet_VAE(SequentialEx):
    "Create a U-Net from a given architecture."
    def __init__(self, encoder:nn.Module, n_classes:int, n_latentdims:Tuple[int,int]=(32,16), img_size:Tuple[int,int]=(256,256), blur:bool=False, blur_final=True, self_attention:bool=False,
                 y_range:Optional[Tuple[float,float]]=None,
                 last_cross:bool=True, bottle:bool=False, **kwargs):
        imsize = img_size
        sfs_szs = model_sizes(encoder, size=imsize)
        sfs_idxs = list(reversed(_get_sfs_idxs(sfs_szs)))
        self.sfs = hook_outputs([encoder[i] for i in sfs_idxs], detach=False)
        x = dummy_eval(encoder, imsize).detach()
       
        ni = sfs_szs[-1][1]
        nx_pix, ny_pix=int(sfs_szs[-1][2]), int(sfs_szs[-1][3])
        
        trialvae=VariationalAutoencoder(ni,nx_pix,ny_pix,n_latentdims[0],**kwargs).eval()
        x = trialvae(x)

        middle_conv = nn.Sequential(conv_layer(ni, ni*2, **kwargs),
                                    conv_layer(ni*2, ni, **kwargs)).eval()
        x = middle_conv(x)
        #layers = [encoder, batchnorm_2d(ni), nn.ReLU(), trialvae]
        layers = [encoder, batchnorm_2d(ni), nn.ReLU(), middle_conv]
        for i,idx in enumerate(sfs_idxs):
            not_final = i!=len(sfs_idxs)-1
            up_in_c, x_in_c = int(x.shape[1]), int(sfs_szs[idx][1])
            x_pix, y_pix=int(sfs_szs[idx][2]), int(sfs_szs[idx][3])
            print('current layer tensor size')
            print((up_in_c, x_in_c, x_pix,y_pix))
            print((i,idx))
            do_blur = blur and (not_final or blur_final)
            sa = self_attention and (i==len(sfs_idxs)-3)
            #if i<1:
            #  unet_block = UnetBlock_VAE_list(up_in_c, x_in_c, x_pix,y_pix, n_latentdims[1], self.sfs[i], final_div=not_final, blur=do_blur, self_attention=sa,
            #                       **kwargs).eval()
            #else: 
            #  unet_block = UnetBlock_VAE_list(up_in_c, x_in_c, x_pix,y_pix, n_latentdims[0], self.sfs[i], final_div=not_final, blur=do_blur, self_attention=sa,
            #                       **kwargs).eval()

            if i<2:
              unet_block = UnetBlock_VAE_decoder(up_in_c, x_in_c, x_pix,y_pix, n_latentdims[1], self.sfs[i], final_div=not_final, blur=do_blur, self_attention=sa,
                                   **kwargs).eval()
            else: 
              unet_block = UnetBlock_VAE_decoder(up_in_c, x_in_c, x_pix,y_pix, n_latentdims[0], self.sfs[i], final_div=not_final, blur=do_blur, self_attention=sa,
                                   **kwargs).eval()
            layers.append(unet_block)
            x = unet_block(x)
            

        ni = x.shape[1]
        if imsize != sfs_szs[0][-2:]: layers.append(PixelShuffle_ICNR(ni, **kwargs))
        x = PixelShuffle_ICNR(ni)(x)
        if imsize != x.shape[-2:]: layers.append(Lambda(lambda x: F.interpolate(x, imsize, mode='nearest')))
        if last_cross:
            layers.append(MergeLayer(dense=True))
            ni += in_channels(encoder)
            layers.append(res_block(ni, bottle=bottle, **kwargs))
        layers += [conv_layer(ni, n_classes, ks=1, use_activ=False, **kwargs)]
        if y_range is not None: layers.append(SigmoidRange(*y_range))
        super().__init__(*layers)

    def __del__(self):
        if hasattr(self, "sfs"): self.sfs.remove()

from fastai.vision.learner import *
def _default_split(m:nn.Module): return (m[1],)
#def _resnet_split(m:nn.Module): return (m[0][6],m[1])
def _resnet_split(m:nn.Module): return (m[0][6],m[4],m[4].layerlist[1],m[5],m[5].layerlist[1],m[6],m[6].layerlist[1],m[7],m[7].layerlist[1])
_default_meta     = {'cut':None, 'split':_default_split}
_resnet_meta      = {'cut':-2, 'split':_resnet_split }
model_meta = {
    models.resnet18 :{**_resnet_meta}, models.resnet34: {**_resnet_meta},
    models.resnet50 :{**_resnet_meta}, models.resnet101:{**_resnet_meta}}
def cnn_config(arch):
    "Get the metadata associated with `arch`."
    torch.backends.cudnn.benchmark = True
    return model_meta.get(arch, _default_meta)
def unet_vae_learner(data:DataBunch, arch:Callable, pretrained:bool=True, blur_final:bool=True, 
                 norm_type:Optional[NormType]=None, split_on:Optional[SplitFuncOrIdxList]=None, blur:bool=False,
                 self_attention:bool=False, y_range:Optional[Tuple[float,float]]=None,latentdims:Optional[Tuple[int,int]]=None,last_cross:bool=True,
                 bottle:bool=False, cut:Union[int,Callable]=None, **learn_kwargs:Any)->Learner:
    "Build Unet learner from `data` and `arch`."
    meta = cnn_config(arch)
    print(cut)
    body = create_body(arch, pretrained, cut)
    try:    size = data.train_ds[0][0].size
    except: size = next(iter(data.train_dl))[0].shape[-2:]
    model = to_device(DynamicUnet_VAE(body, n_classes=data.c, n_latentdims = latentdims, img_size=size, blur=blur, blur_final=blur_final,
          self_attention=self_attention, y_range=y_range, norm_type=norm_type, last_cross=last_cross,
          bottle=bottle), data.device)
    learn = Learner(data, model, **learn_kwargs)
    learn.split(ifnone(split_on, meta['split']))
    if pretrained: learn.freeze()
    apply_init(model[2], nn.init.kaiming_normal_)
    return learn

